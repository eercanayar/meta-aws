AWSTemplateFormatVersion: '2010-09-09'
Parameters:
  EnvironmentName:
    Description: Enter the branch used to initiate the deployment
    Default: aws-gg-demo
    Type: String
Mappings:
  Region2S3WebsiteSuffix:
    us-east-1:
      Suffix: .s3.us-east-1.amazonaws.com
    us-west-1:
      Suffix: .s3.us-west-1.amazonaws.com
    us-west-2:
      Suffix: .s3.us-west-2.amazonaws.com
    eu-west-1:
      Suffix: .s3.eu-west-1.amazonaws.com
    ap-northeast-1:
      Suffix: .s3.ap-northeast-1.amazonaws.com
    ap-northeast-2:
      Suffix: .s3.ap-northeast-2.amazonaws.com
    ap-southeast-1:
      Suffix: .s3.ap-southeast-1.amazonaws.com
    ap-southeast-2:
      Suffix: .s3.ap-southeast-2.amazonaws.com
    ap-south-1:
      Suffix: .s3.ap-south-1.amazonaws.com
    us-east-2:
      Suffix: .s3.us-east-2.amazonaws.com
    sa-east-1:
      Suffix: .s3.sa-east-1.amazonaws.com
    cn-north-1:
      Suffix: .s3.cn-north-1.amazonaws.com.cn
    eu-central-1:
      Suffix: .s3.eu-central-1.amazonaws.com

Resources:
  ThingsListFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Ref EnvironmentName
      Environment:
        Variables:
          REGION: !Ref 'AWS::Region'
          APIKey: !Select [2, !Split ['/', !Ref AWS::StackId]]
      Role: !GetAtt LambdaExecutionRole.Arn
      Handler: index.lambda_handler
      Code: 
        ZipFile: | 
          import boto3
          import json
          import os
          client = boto3.client('iot', region_name=os.environ['REGION'])
          def lambda_handler(event, context):
              print(event)
              if  not "queryStringParameters" in event or not "APIKey" in event["queryStringParameters"] or os.environ['APIKey'] != event["queryStringParameters"]['APIKey']:
                return {
                  'statusCode': 403,
                }
              response = client.list_things(
                  maxResults=123,
                  usePrefixAttributeValue=False
                  )
              things = []
              for thing in response['things']:
                  try:
                      thing['lat'] = float(thing['attributes']['lat'] )
                      thing['lng'] = float(thing['attributes']['lng'] )
                  except:
                      thing['lat'] = 0
                      thing['lng'] = 0
                  thing.pop('attributes')
                  things.append(thing)
              return {
                  'statusCode': 200,
                  'body': json.dumps({'things': things})
              }

      Runtime: python3.8
      MemorySize: 1000
      Timeout: 900
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - logs:*
            - iot:*
            Resource: '*'


  ThingListLambdaUrl:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: NONE
      Cors:
        AllowOrigins: 
          - "*"
      TargetFunctionArn: !GetAtt ThingsListFunction.Arn

  FunctionUrlPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !GetAtt ThingsListFunction.Arn
      FunctionUrlAuthType: NONE
      Principal: "*"

  # Create a role for unauthorized acces to AWS resources. Very limited access. Only allows users in the previously created Identity Pool
  CognitoUnAuthorizedRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument: 
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal: 
              Federated: "cognito-identity.amazonaws.com"
            Action: 
              - "sts:AssumeRoleWithWebIdentity"
            Condition:
              StringEquals: 
                "cognito-identity.amazonaws.com:aud": !Ref IdentityPool
              "ForAnyValue:StringLike":
                "cognito-identity.amazonaws.com:amr": unauthenticated
      Policies:
        - PolicyName: "CognitoUnauthorizedPolicy"
          PolicyDocument: 
            Version: "2012-10-17"
            Statement: 
              - Effect: "Allow"
                Action:
                  - "mobileanalytics:PutEvents"
                  - "cognito-sync:*"
                  - "kinesisvideo:*"
                Resource: "*"

  # Create a role for authorized acces to AWS resources. Control what your user can access. This example only allows Lambda invokation
  # Only allows users in the previously created Identity Pool
  CognitoAuthorizedRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument: 
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal: 
              Federated: "cognito-identity.amazonaws.com"
            Action: 
              - "sts:AssumeRoleWithWebIdentity"
            Condition:
              StringEquals: 
                "cognito-identity.amazonaws.com:aud": !Ref IdentityPool
              "ForAnyValue:StringLike":
                "cognito-identity.amazonaws.com:amr": authenticated
      Policies:
        - PolicyName: "CognitoAuthorizedPolicy"
          PolicyDocument: 
            Version: "2012-10-17"
            Statement: 
              - Effect: "Allow"
                Action:
                  - "mobileanalytics:PutEvents"
                  - "cognito-sync:*"
                  - "cognito-identity:*"
                Resource: "*"

  IdentityPool:
    Type: AWS::Cognito::IdentityPool
    Properties: 
      AllowClassicFlow: true
      AllowUnauthenticatedIdentities: true
      IdentityPoolName: !Ref EnvironmentName

  identityUnauthRoleAttach:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    Properties: 
      IdentityPoolId: !Ref IdentityPool
      Roles:
        authenticated: !GetAtt CognitoAuthorizedRole.Arn
        unauthenticated: !GetAtt CognitoUnAuthorizedRole.Arn

  S3BucketForWebsiteContent:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: Private
      PublicAccessBlockConfiguration:
          BlockPublicAcls: true
          BlockPublicPolicy: true
          IgnorePublicAcls: true
          RestrictPublicBuckets: true
  WebsiteCDN:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Comment: CDN for S3-backed website
        Enabled: 'true'
        DefaultCacheBehavior:
          ForwardedValues:
            QueryString: 'true'
          TargetOriginId: only-origin
          ViewerProtocolPolicy: allow-all
        DefaultRootObject: index.html
        Origins:
        - DomainName: !Join ['', [!Ref 'S3BucketForWebsiteContent', !FindInMap [Region2S3WebsiteSuffix,
                !Ref 'AWS::Region', Suffix]]]
          Id: only-origin
          S3OriginConfig:
              OriginAccessIdentity: !Join [ "", [ "origin-access-identity/cloudfront/", !Ref TheCloudFrontOriginAccessIdentity ] ]
        
  TheCloudFrontOriginAccessIdentity:
      Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
      Properties:
        CloudFrontOriginAccessIdentityConfig:
          Comment: !Sub 'CloudFront OAI for ${S3BucketForWebsiteContent}'

  OAIBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref S3BucketForWebsiteContent
      PolicyDocument:
        Version: "2008-10-17"
        Id: "PolicyForCloudFrontPrivateContent"
        Statement:
          - Action:
              - 's3:GetObject'
            Effect: Allow
            Resource: !Sub "arn:aws:s3:::${S3BucketForWebsiteContent}/*"
            Principal:
              AWS: !Sub "arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${TheCloudFrontOriginAccessIdentity}"

Outputs:
  IdentityPoolID:
    Value: !Ref IdentityPool
  IdentityPoolRoleArn:
    Value: !GetAtt CognitoUnAuthorizedRole.Arn
  BucketName:
    Value: !Ref S3BucketForWebsiteContent
  WebSite:
    Value: !GetAtt WebsiteCDN.DomainName
  DistributionId:
    Value: !Ref WebsiteCDN
  FunctionURL:
    Value: !GetAtt ThingListLambdaUrl.FunctionUrl
  APIKey:
    Value: !Select [2, !Split ['/', !Ref AWS::StackId]]
